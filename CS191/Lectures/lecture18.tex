\section{Lecture 18}

\subsection{Toric Code, Continued}
Recall that we had a toroidal lattice (the top connects to the bottom and left connects to the right) on which, we placed
a qubit on each edge $e$. These gave rise to vertex and plaquette operators, $A_v = \prod_{e \in e(v)} X_e$ and $B_p = \prod_{e \in e(p)} Z_e$.
We saw these stabilizers gave a $\llbracket n = 2L^2, k = 2, d = ?? \rrbracket$ code. Let's find that last parameter.

\begin{theorem}
The Toric code is a $\llbracket 2L^2, 2, L \rrbracket$ code.

\begin{proof*}
    We need to find the minimum number of qubits
    $E^{\dagger}_k E_l$ acts on such that $[E_k^{\dagger} E_l, A_v] = [E_k^{\dagger} E_l, B_p] = 0$ but is not generated, i.e. $E_k^{\dagger} E_l \neq \prod_{v_i} A_{v_i} \prod_{p_j} B_{p_j}$.
    We saw that $E_k^{\dagger} E_l = \prod_{e \in e_x} X_e \prod_{e \in e_z} Z_e$ commuting with all stabilizers
    was equivalent to $e_z$ forms a set of closed loops and and $e_x$ forms a set of closed loops in the dual lattice. 

    But this is not a hard condition, consider
    $E_k^{\dagger} E_l = B_p$ (i.e. a closed loop of a square). But this doesn't tell us anything about the distance, because it's still generated by our set of stabilizers.
    So, we must ask, what is the smallest operator $E_k^{\dagger} E_l$ which is not generated. The $e_z$ and $e_x$ are independent, so the smallest
    operator has only $Z$'s or only $X$'s. Let's consider only $Z$'s without loss of generality. A loop that cannot we written as a product of vertex and plaquette operators is called a \textbf{noncontractible loop}.
    Such a loop would be a vertical or horizontal line, remember that the edges are glued together. We can also form a noncontractible loop using $X$'s by using the dual lattice (take the horizontal edges along any vertical line that is not grid-aligned).
    So we can correct up to $L$ distance.
\end{proof*}
\end{theorem}

Now let's consider the following commutators:
\begin{align*}
    \qty[\prod_{e \in \text{vertical loop}} X_e, \prod_{e \in \text{vertical loop}} Z_e] &= 0 \\
    \qty{\prod_{e \in \text{horizontal loop}} X_e, \prod_{e \in \text{vertical loop}} Z_e} &= 0
\end{align*}
By these commutation relations, we can identify logical operators as the following:
\begin{align*}
    \tilde{X}_1 &= \prod_{e \in \text{v. loop}} X_e \\
    \tilde{X}_2 &= \prod_{e \in \text{h. loop}} X_e \\
    \tilde{Z}_1 &= \prod_{e \in \text{h. loop}} Z_e \\
    \tilde{Z}_2 &= \prod_{e \in \text{v. loop}} Z_e
\end{align*}
Such an error-correcting code is termed as using \textbf{Topological Quantum Error Correction}.

\subsection{Fault Tolerance}
We want to build a quantum computer with quantum error correction. But the error-correction itself is made up of quantum gates, and may itself be faulty.
So we must somehow resolve this.
The first results we care about are threshold theorems. There are many for different error-correcting codes, but they all are statements of the following form:
\begin{ptheorem}[Threshold Theorem]
    Call $p_T$ the thereshold probability, which depends
    on the code we use and our fault-tolerance procedure. If you can build a physical quantum computer with ``error probability per gate'' $p < p_T$
    This means we can build a logical quantum computer with error probability per gate $p' < p$.
\end{ptheorem}
As a consequence, we can iteratively build more and more fault-tolerant quantum computers and make the error rate arbitrarily small. The first proofs
had threshold $p_T = O(10^{-7})$, which was useless for practice. Now we have gotten $p_T = O(10^{-3})$.

So how does this model work? We have two main sources of issues:
\begin{enumerate}
    \item Carrying out error-correction can create new errors.
    \item Implementing logical gates can create errors.
\end{enumerate}
On issue 1, a syndrome measurement can not only create new errors, but can spread errors.
Suppose we'd like to measure $Z_1 Z_2 Z_3 Z_4$ on some four physical qubits. The usual way to do this is:
\begin{center}
\begin{quantikz}
    \qw & \ctrl{4} & \qw & \qw & \qw & \qw\\
    \qw & \qw & \ctrl{3} & \qw & \qw & \qw\\
    \qw & \qw & \qw & \ctrl{2} & \qw & \qw \\
    \qw & \qw & \qw & \qw & \ctrl{1} & \qw \\
    \lstick{$\ket{0}$} & \targ\qw & \targ\qw & \targ\qw & \targ \qw& \meter{}
\end{quantikz}
\end{center}
But suppose there's an error on the Ancilla qubit. Then this single error ``infects'' all four physical qubits.
We want an approach to do these measurements so any single-qubit error cannot affect more than 1 physical qubit.
Let's instead use 4 physical qubits:
\begin{center}
\begin{quantikz}
    \qw & \ctrl{4} & \qw & \qw & \qw & \qw\\
    \qw & \qw & \ctrl{4} & \qw & \qw & \qw\\
    \qw & \qw & \qw & \ctrl{4} & \qw & \qw \\
    \qw & \qw & \qw & \qw & \ctrl{4} & \qw \\
    \lstick[wires=4]{$\sum_{x: \mathrm{wt}(x) = 0 \pmod{2}} \ket{x}$} & \targ\qw & \qw & \qw & \qw & \meter{} \\
                            \qw & \qw & \targ\qw & \qw & \qw & \meter{} \\
                            \qw & \qw & \qw & \targ\qw & \qw & \meter{} \\
                            \qw & \qw & \qw & \qw & \targ\qw & \meter{} \\
\end{quantikz}
\end{center}
Now after measurement, if there are an even number of 1s then there is no error and if there are an odd number, there is an error, but we learn no other information about the physical qubits.
But now there's another issue, how do we create this superposition over $\ket{x}$ in a fault-tolerant way? We claim
\[ \sum_{x: \mathrm{wt}(x) = 0 \pmod{2}} \ket{x}  = H^{\otimes 4} \ftwo \qty(\ket{0000} + \ket{1111}) \]

\begin{center}
\begin{quantikz}
    \lstick{$\ket{0}$} & \gate{H} & \ctrl{1} & \qw & \qw & \qw\\
    \lstick{$\ket{0}$} & \qw & \targ\qw & \ctrl{1} & \qw & \qw\\
    \lstick{$\ket{0}$} & \qw & \qw & \targ\qw & \ctrl{1} & \qw \\
    \lstick{$\ket{0}$} & \qw & \qw & \qw & \targ\qw & \qw \\
\end{quantikz}
\end{center}
This does not work if we have an error on the first or fourth qubit. Let's add another ancilla qubit
to check for this:
\begin{center}
\begin{quantikz}
    \lstick{$\ket{0}$} & \gate{H} & \ctrl{1} & \qw & \qw & \qw & \ctrl{4}\qw & \qw\\
    \lstick{$\ket{0}$} & \qw & \targ\qw & \ctrl{1} & \qw & \qw & \qw & \qw \\
    \lstick{$\ket{0}$} & \qw & \qw & \targ\qw & \ctrl{1} & \qw & \qw & \qw \\
    \lstick{$\ket{0}$} & \qw & \qw & \qw & \targ\qw & \ctrl{1}\qw & \qw & \qw\\
    \lstick{$\ket{0}$} & \qw & \qw & \qw & \qw & \targ\qw & \targ\qw & \qw\\
\end{quantikz}
\end{center}
If we measure $0$, then no dangerous errors happened, so just keep trying until we measure 0.

Now on issue 2, the stupid way would be to decode logical qubit into physical qubit, implement the gate, then reencode. But during the gate, we could get an error and be unable to correct it.
Thus, we need to implement the logical gates while everything is encoded, like we saw in the toric code $\tilde{X}_1 = \prod_{e \in \text{horiz. loop}} X_e$.
So, there is no error spreading because each gate is a 1-qubit gate. This is called a \textbf{transversal logical gate} and so only acts as a product over physical qubits.
\begin{definition}
    A gate $U$ is said to be a \textbf{Clifford gate} if the group of Paulis is invariant under its conjugation.
    \[ U \mathcal{G}_n U^{\dagger} = \mathcal{G}_n \]
\end{definition}

\begin{theorem}
    For any stabilizer code, any Clifford gates $U$ can be implemented transversally.
\end{theorem}

\begin{theorem}
    The set of all Clifford gates can be generated by:
    \[ \langle H, CNOT, S \rangle \]
    where $S = \ketbra{0} + i \ketbra{1}$.
\end{theorem}

\begin{theorem}
    Clifford gates can be simulated efficiently using classical computers.
\end{theorem}

If all we can do is Clifford gates, what was the point?

\begin{theorem}[Eastin-Knill]
    There is no quantum-error correction where a universal gate set can be implemented transversally.
\end{theorem}

But actually, for any stabilizer code, we only need to implement one non-Clifford gate to do any computation we want.
\[ T = \ketbra{0} + e^{i\pi/4} \ketbra{1} \]
Now to implement any other gate we first consider the magic state:
\[ \ket{\tilde{\pi/4}} = \ftwo \qty(\ket{\tilde{0}} + e^{i\pi/4} \ket{\tilde{1}})\]
Then this is the implementation of that gate:
\begin{center}
\begin{quantikz}
    \lstick{$\ket{\tilde{\psi}}$} & \targ\qw & \ctrl{1}\qw & \qw \\
    \lstick{$\ket{\tilde{\pi/4}}$} & \ctrl{-1}\qw & \gate{\tilde{S} \tilde{X}} & \qw\rstick{$\tilde{T} \ket{\tilde{\psi}}$}
\end{quantikz}
\end{center}
But note that $\ket{\tilde{\pi/4}}$ is an eigenstate of $SX$ which is Clifford.
\begin{center}
\begin{quantikz}
    \lstick{$\ket{0}$} & \gate{H} & \gate{T^{\dagger}} & \ctrl{1} & \gate{H} & \meter{} \\
    \lstick{$\ket{\tilde{\psi}}$} & \qw & \qw & \gate{SX} & \qw &
\end{quantikz}
\end{center}
However, this is not fault-tolerant, because error on the first ancilla qubit propogates to all of the logical qubits. This can be fixed
using exactly the same techniques we used for the syndrome measurement.