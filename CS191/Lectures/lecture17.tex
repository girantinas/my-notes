\section{Lecture 17}

\subsection{More Stabilizer Codes}
Recall our definition for a Stabilizer code, succinctly written.
\begin{definition}
    A \textbf{Stabilizer code} over a space $\H_A$ is a subspace $\H_{code} \subseteq \H_A$ defined as follows:
    \[ \H_{code} = \left\{\ket{\tilde{\psi}} \mid \ket{\tilde{\psi}} \in \H_A, \text{ } \forall i \text{ } M_i \ket{\tilde{\psi}} = \ket{\tilde{\psi}} \right\} \]
    where $\{ M_i\}$ is a set of operators from $\mathcal{G}_n$ that satisfy the following conditions:
    \begin{enumerate}
        \item They commute. $[M_i, M_j] = M_i M_j - M_j M_i = 0$.
        \item They are independent. Namely, there is no $M_i = M_{i_1} M_{i_2} \dots$.
        \item They are Hermitian. $M_i = M_i^{\dagger}$
    \end{enumerate} 
\end{definition}

If we have $n - k$ stabilizers, then there are $n - k$ linearly independent conditions,
and the dimension of this subspace (the size of the code) is $\dim(\H_{code}) = 2^{n - (n - k)} = 2^k$.
This yields a very succinct way to realize the code as quantum gates.

\begin{theorem}[Implementing Stabilizer Codes]
If we implement $\{M_i\}$ as syndrome measurements and apply appropriate corrections, we can correct any error
on up to some number of qubits.

    To show this, first consider some error $E_k \in \mathcal{G}_n$. We then have two cases:
    \begin{enumerate}
        \item $[E_k, M_i] = 0$, which means $M_i E_k \ket{\tilde{\psi}} = E_k M_i \ket{\tilde{\psi}} = E_k \ket{\tilde{\psi}}$,
        and we have an eigenvalue of +1.
        \item $\{E_k, M_i\} = 0$, which means $M_i E_k \ket{\tilde{\psi}} = - E_k M_i \ket{\psi} = -E_k \ket{\psi}$,
        and we have an eigenvalue of -1.
    \end{enumerate}
            
            The Knill-Laflamme conditions say that for QEC to be possible, we must show
            \[ \mel{\tilde{i}}{E_k^{\dagger} E_{l}}{\tilde{j}} = \delta_{ij} M_{k l} \]
            We study three cases.
            \begin{enumerate}
                \item $E_k^{\dagger} E_{l} = M_{i_1} M_{i_2} \dots$, i.e. it is in the group generated by the $M_{i}$'s. Then,
                since $\ket{\tilde{i}}$ are eigenvectors of the $M_i$'s with eigenvalue +1, they also have the same eigenvalue for $E_k^{\dagger} E_{l}$.
                So $\mel{\tilde{i}}{E_k^{\dagger} E_l}{\tilde{j}} = \ketbra{\tilde{i}}{\tilde{j}} = \delta_{ij}$.
                \item $\{E_k^{\dagger} E_l, M_i\} = 0$ for some $i$. Then $E_k^{\dagger} E_l \ket{\tilde{j}}$ is an eigenvector of $M_i$ with eigenvalue $-1$ (by the above),
                but $\ket{\tilde{i}}$ is an eigenvector with eigenvalue $+1$, so they must be orthogonal, so $\ket{\tilde{i}}{E_k^{\dagger} E_l}{\tilde{j}} = 0 = 0 \delta_{ij}$.
                \item $[E_k^{\dagger} E_l, M_i] = 0$ for all $i$, but is not in case 1. Then $E_k^{\dagger} E_l \ket{\tilde{j}} \in \H_{code} \neq \ket{\tilde{j}}$ in general.
                \emph{So we cannot prove the Knill-Laflamme conditions.}
            \end{enumerate}
    In the first and second case, we are good. Suppose we find these $\{M_i\}$ such that
    for all $i$, $[M, M_i] = 0$ for some Pauli operator $M$. This corresponds to $M$ acting on at least $d$ qubits, which we will call the \textbf{distance} of the code.
    We thus limit our discussion to $E_k = \{ I, \text{All Pauli operators on $(d - 1)/2$ qubits} \}$. Then, $E_k^{\dagger} E_l$ acts on at most $d - 1$ qubits,
    meaning $\H_{code}$ satisfies Knill-Laflamme conditions.
\end{theorem}

\begin{example}
    To see the $d-1 = 2$ qubits in action, let's take a look at the Shor code.
    \[ \{M_i\} = \{ Z_1 Z_2, Z_2 Z_3, Z_4 Z_5, Z_5 Z_6, Z_7 Z_8, Z_8 Z_9, X_1 X_2 X_3 X_4 X_5 X_6, X_4 X_5 X_6 X_7 X_8 X_9 \}\]
    One example of 2 qubits that commute with all the $M_i$'s is $Z_1Z_2$, i.e. $[Z_1Z_2, M_i] = 0$ for all $i$. Note that there does not exist 
    an operator $M \not \in \{M_i\}$ such that $[M, M_i] = 0$ for all $i$ and $M$ acts on $<3$ qubits.
\end{example}

\begin{definition}
    A quantum error-correcting code with $n$ physical qubits, $k$ logical qubits and distance $d$ is denoted as a
    $\llbracket n, k, d \rrbracket$ quantum error-correcting code.
\end{definition}

So, we have shown the Shor code is a $\llbracket 9, 1, 3 \rrbracket$ quantum error-correcting code. 
\begin{theorem}
    If a quantum error correcting code has distance $d$, it can correct arbitrary errors on up to any $\frac{d-1}{2}$ qubits. 
\end{theorem}
There are also other codes that perform better than the Shor code:
\begin{example}[Steane Code]
    The \textbf{Steane code} is a $\llbracket 7, 1, 3 \rrbracket$ stabilizer code with $(n-k) = 6$ stabilizers:
    \[ \{ Z_1 Z_3 Z_5 Z_7, Z_2 Z_3 Z_6 Z_7, Z_4 Z_5 Z_6 Z_7, X_1 X_3 X_5 X_7, X_2 X_3 X_6 X_7, X_4 X_5 X_6 X_7  \} \]
    Clearly the $Z_i$'s commute, but to see that the $Z$'s and $X$'s commute, notice that each product of $Z$'s shares an even number of factors with
    each product of $X$'s. The logical operators $\tilde{X}$ and $\tilde{Z}$ can be implemented using $X_1X_2X_3X_4X_5X_6X_7$ and $Z_1Z_2Z_3Z_4Z_5Z_6Z_7$, respectively.
\end{example}

\begin{example}[Five-qubit Code]
    The \textbf{Five-qubit code} is a $\llbracket 5, 1, 3 \rrbracket$ stabilizer code with stabilizers:
    \[ \{X_1 Z_2 Z_3 X_4, X_2 Z_3 Z_4 X_5, X_1 X_3 Z_4 Z_5, Z_1 X_2 X_4 Z_5\} \]
    The logical operators $\tilde{X}$ and $\tilde{Z}$ can be implemented using $X_1X_2X_3X_4X_5$ and $Z_1Z_2Z_3Z_4Z_5$, respectively.
\end{example}

One may ask if we can do better. The answer is no.
\begin{example}
    There is no $\llbracket 4, 1, 3 \rrbracket$ code.

    \begin{proof*}
        Consider the set of errors $E_k$ that only act on the first two qubits, so $E_k^{\dagger} E_l$ acts on first two qubits. Consider an arbitrary state $\ket{\tilde{\psi}}$.
        Send the first two physical qubits to Alice and the last two physical qubits to Bob. Then both Alice and Bob could recover $\ket{\tilde{\psi}}$,
        but this would clone the state! So such a code could not exist.
    \end{proof*}
\end{example}



\subsection{Toric Code}
Consider a square lattice. We are going to place one physical qubit on each edge of the lattice.
Further we add a toroidal topology, so the top of the lattice is connected to the bottom and the right of the lattice is connected to the left.
Let $v$ be a vertex, $e$ be an edge (physical qubit) and $p$ be a face (plaquette) of this lattice. Define $e(p) = \{ e : e = \{p, \cdot\}\}$ and
$A_v = \prod_{e(p)} X_e$. Since each vertex has 4 incident edges, there are 4 $X$ operators and $B_p = \prod_{e(p)} Z_p$
where we mean incident edges in the dual graph, i.e. the edges surrounding the face. Again, there are 4 per face, so this is very explicit.

We check the commutation of stabilizers. Since $X$'s and $Z$'s commute with themselves, we directly have
\[ [A_v, A_{v'}] = 0, [B_p, B_{p'}] = 0 \]
Now, we explore $[A_v, B_p]$. They clearly commute if they share no edges. If they share an edge, then $v$ must be a corner of $p$,
so they share exactly two edges. But each of these introduce a minus sign when commuted, which cancel to 0, i.e. $[X_1 X_2, Z_1 Z_2] = 0$.
Thus, all these operators commute and form a valid set of stabilizers. 

Suppose the lattice has size $L$. What is the number of logical qubits here?
\[ \dim (\H_{phys}) = 2^{\text{\# of edges}} = 2^{2L^2} \]
How many independent stabilizers do we have? Since we have $L^2$ vertices and $L^2$ plaquettes, does this mean we have $2L^2$ stabilizers? But wait,
not all of these are independent, because $\prod_v A_v = I$ (by the handshake theorem, every vertex contributes
two copies of every $X$ operator, and $X_i^2 = I_i$, so this leads to the identity). Similarly, $\prod_p B_p = I$. So we've overcounted by 1 for each of the vertex and plaquette stabilizer types. 
Thus, we actually only have $2L^2 - 2$ independent
stabilizers. 

Hence, when we have $k = 2$ logical qubits the dimension of $H_{code}$ is 
\[\dim (\H_{code}) = 2^{2L^2 - (2L^2 - 2)} = 2^2 = 4.\] 
Now, let's find its distance.
Suppose $[E_k^{\dagger} E_l, A_v] = 0$ for all $v$ and $[E_k^{\dagger} E_l, B_p] = 0$ for all $p$. We know that for some set $e_X, e_Z$:
\[ E_k^{\dagger} E_l = \pm \prod_{i \in e_X} X_i \prod_{j \in e_Z} Z_j \]
So $[E_k^{\dagger} E_l, A_v] = 0$ if and only if $e_Z$ and $e(v)$ share $0, 2$, or $4$ edges (i.e. an even number of edges).
Such a graph must be a set of closed loops. Similarly, $[E_k^{\dagger} E_l, B_p] = 0$ if and only if $e_X$ and $e(p)$
share an even number of edges. This means the dual lattice must be a set of closed loops.
